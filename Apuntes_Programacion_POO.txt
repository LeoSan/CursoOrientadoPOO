¬øPor qu√© aprender Programaci√≥n Orientada a Objetos?

La programaci√≥n orientada a objetos tiene cuatro caracter√≠sticas principales:
Encapsulamiento. Quiere decir que oculta datos mediante c√≥digo.

- Abstracci√≥n. Es como se pueden representar los objetos en modo de c√≥digo.
- Herencia. Es donde una clase nueva se crea a partir de una clase existente.
- Polimorfismo. Se refiere a la propiedad por la que es posible enviar mensajes sint√°cticamente iguales a objetos de tipos distintos.

En este curso, los pasos a seguir ser√°.
Analisis
Plasmar
Programar
La mayor√≠a solo aprende a hacer esto en un lenguajes de programaci√≥n,aqu√≠ se tiene una variabilidad. ‚ù§Ô∏è



¬øQu√© resuelve la Programaci√≥n Orientaci√≥n a Objetos?



- Principalmente esos problemas y huecos que nos deja la programaci√≥n estructurada tales como:
1.C√≥digo muy largo:
2.Si algo falla todo se rompe
3.C√≥digo Spaguetti: Muchas sentencias de control anidadas y p√©rdida de control sobre el c√≥digo.

- Simplifica la programaci√≥n, la hace m√°s pr√°ctica, divertida y amigable.

¬øQu√© nos ayuda a resolver la POO?
Huecos que la programaci√≥n estructurada no resuelve, por lo que la estructuraci√≥n por objetos surgi√≥ como una soluci√≥n.

Ayuda a leer, depurar y mantener c√≥digo que puede ser muy largo.
Evita que todo se rompa si algo falla.
Facilita el mantenimiento del c√≥digo.
Evita generar un c√≥digo espaguetti. Aqu√©l que tiene demasiadas sentencias de control anidadas.

######################################################################################################################
# Paradigma Orientado a Objetos

La Programaci√≥n Orientada a Objetos viene de una filosof√≠a o forma de pensar que es la Orientaci√≥n a Objetos y esto surge a partir de los problemas que necesitamos plasmar en c√≥digo.

Es analizar un problema en forma de objetos para despu√©s llevarlo a c√≥digo, eso es la Orientaci√≥n a Objetos.

Un paradigma es una teor√≠a que suministra la base y modelo para resolver problemas. La paradigma de Programaci√≥n Orientada a Objetos se compone de 4 elementos:

Clases
Propiedades
M√©todos
Objetos
Y 4 Pilares:

Encapsulamiento
Abstracci√≥n
Herencia
Polimorfismo

######################################################################################################################
# Lenguajes Orientados a Objetos

Algunos de los lenguajes de programaci√≥n Orientados a Objetos son:

Java:
‚Äì Orientado a Objetos naturalmente
‚Äì Es muy √∫tilizado en Android
‚Äì Y es usado del lado del servidor o Server Side
PHP
‚Äì Lenguaje interpretado
‚Äì Pensado para la Web
Python
‚Äì Dise√±ado para ser f√°cil de usar
‚Äì M√∫ltiples usos: Web, Server Side, An√°lisis de Datos, Machine Learning, etc
Javascript
‚Äì Lenguaje interpretado
‚Äì Orientado a Objetos pero basado en prototipos
‚Äì Pensado para la Web
C#
Ruby
Kotlin

######################################################################################################################
#Lenguajes basados en clases vs. basados en prototipos


Los lenguajes orientados a objetos basados en clases, como Java y C++, 
se basan en el concepto de dos entidades distintas: clases e instancias.


Una clase define todas las propiedades (considerando como propiedades los 
m√©todos y campos de Java, o los miembros de C++) que caracterizan un determinado 
conjunto de objetos. Una clase es una entidad abstracta, m√°s que cualquier miembro 
en particular del conjunto de objetos que describe. Por ejemplo, la clase Empleado 
puede representar al conjunto de todos los empleados.

Una instancia, por otro lado, es la instanciaci√≥n de una clase; es decir, uno 
de sus miembros. Por ejemplo, Victoria podr√≠a ser una instancia de la clase Empleado, 
representando a un individuo en particular como un empleado. Una instancia tiene exactamente 
las mismas propiedades de su clase padre (ni m√°s, ni menos).

Imgur
Un lenguaje basado en prototipos, como JavaScript, no hace esta distinci√≥n: 
simplemente tiene objetos. Un lenguaje basado en prototipos toma el concepto de objeto 
protot√≠pico, un objeto que se utiliza como una plantilla a partir de la cual se obtiene 
el conjunto inicial de propiedades de un nuevo objeto. Cualquier objeto puede especificar sus 
propias propiedades, ya sea cuando es creado o en tiempo de ejecuci√≥n. Adicionalmente, cualquier
 objeto puede ser utilizado como el prototipo de otro objeto, permitiendo al segundo objeto compartir 
 las propiedades del primero.
 
###################################################################################################################### 
# Diagramas de Modelado

OMT: Object Modeling Techniques. Es una metodolog√≠a para el an√°lisis orientado a objetos.
Creado en OMT 1991. Se encuentra en desuso.

UML: Unified Modeling Language o Lenguaje de Modelado Unificado. Tom√≥ las bases y t√©cnicas 
de OMT unific√°ndolas. Tenemos m√°s opciones de diagramas como lo son Clases, Casos de Uso, Objetos, Actividades, Iteraci√≥n, Estados, Implementaci√≥n.
Modelar: 
+Clases
+Casos de Uso
+Objetos
+Iteraci√≥n
+Estados
+Implementaci√≥n 

Creado en 1997.


Esto significa que tendremos una manera gr√°fica de representar una situaci√≥n, justo como hemos venido viendo. A continuaci√≥n te voy a presentar los elementos que puedes utilizar para hacer estas representaciones.

Las clases se representan as√≠:

clase.png
En la parte superior se colocan los atributos o propiedades, y debajo las opera ciones de la clase. Notar√°s que el primer caracter con el que empiezan es un s√≠mbolo. Este denotar√° la visibilidad del atributo o m√©todo, esto es un t√©rmino que tiene que ver con Encapsulamiento y veremos m√°s adelante a detalle.

Estos son los niveles de visibilidad que puedes tener:

- private
+ public
# protected
~ default

Una forma de representar las relaciones que tendr√° un elemento con otro es a trav√©s de las flechas en UML, y aqu√≠ tenemos varios tipos, estos son los m√°s comunes:

Asociaci√≥n
associacion.png
Como su nombre lo dice, notar√°s que cada vez que est√© referenciada este tipo de flecha significar√° que ese elemento contiene al otro en su definici√≥n. La flecha apuntar√° hacia la dependencia.

uml-relacion-asociacion.jpg
Con esto vemos que la ClaseA est√° asociada y depende de la ClaseB.

Herencia
herencia.png
Siempre que veamos este tipo de flecha se estar√° expresando la herencia.
La direcci√≥n de la flecha ir√° desde el hijo hasta el padre.

herencia-clases.png
Con esto vemos que la ClaseB hereda de la ClaseA

Agregaci√≥n
agregacion.png
Este se parece a la asociaci√≥n en que un elemento depender√° del otro, pero en este caso ser√°: Un elemento depender√° de muchos otros. Aqu√≠ tomamos como referencia la multiplicidad del elemento. Lo que com√∫nmente conocer√≠as en Bases de Datos como Relaciones uno a muchos.

uml-relacion-agregacion.jpg
Con esto decimos que la ClaseA contiene varios elementos de la ClaseB. Estos √∫ltimos son com√∫nmente representados con listas o colecciones de datos.

Composici√≥n
composicion.png
Este es similar al anterior solo que su relaci√≥n es totalmente compenetrada de tal modo que conceptualmente una de estas clases no podr√≠a vivir si no existiera la otra.

uml-relacion-composicion.jpg
Con esto terminamos nuestro primer m√≥dulo. Vamos al siguiente para entender c√≥mo podemos hacer un an√°lisis y utilizar estos elementos para construir nuestro diagrama de clases de Uber.

#################################################################################################################
#Objetos


üí° Es importante tener en cuenta que el atributo no sea el resultado. Ej: el atributo de ser nombre, 
no el resultado del atributo.

Adem√°s, los objetos tambi√©n puede tener comportamientos. Estos ser√°n todas las operaciones del 
objeto, suelen ser ‚Äòverbos‚Äô o ‚Äòsustantivo y verbo‚Äô.

login() ‚Üí Verbo
logout() ‚Üí Verbo
makeReport() ‚Üí Sustantivo y verbo
üìí Es importante tener en cuenta el contexto en que est√°n mis objetos.

Los Objetos son aquellos que tienen propiedades y comportamientos, tambi√©n ser√°n sustantivos.

Pueden ser F√≠sicos o Conceptuales
Las Propiedades tambi√©n pueden llamarse atributos y estos tambi√©n ser√°n sustantivos. Algunos atributos o propiedades son nombre, tama√±o, forma, estado, etc. Son todas las caracter√≠sticas del objeto.

Los Comportamientos ser√°n todas las operaciones que el objeto puede hacer, suelen ser verbos o sustantivos y verbo. Algunos ejemplos pueden ser que el usuario pueda hacer login y logout.

#################################################################################################################
#Clase


Una Clase es el modelo por el cual nuestros objetos se van a construir y nos van a permitir generar m√°s objetos.

Analizamos Objetos para crear Clases. Las Clases son los modelos sobres los cuales construiremos nuestros objetos.

Abstracci√≥n es cuando separamos los datos de un objeto para generar un molde.

#################################################################################################################
#Modularidad
.
La modularidad va de la mano con el Dise√±o Modular, este consiste en dividir 
nuestro sistema en partes peque√±as que funcionen de manera independiente.

Ventajas
-Reutilizar c√≥digo
-Evitar colapsos
-Legibilidad (Todos los elementos viven por s√≠ solos)
-Resoluci√≥n r√°pida de problemas

Debemos empezar a programar en peque√±os trozos, cambiar nuestra forma de pensar y evitar la programaci√≥n estructurada.

Tengamos presentes los principios de la

##################################################################################################################
¬øQu√© es la herencia?

##################################################################################################################
#Cuando detecto caracter√≠sticas y comportamientos iguales, entonces significa que debo realizar una abstracci√≥n.
###################################################################################################################

Don‚Äôt repeat yourself es una filosof√≠a que promueve la reducci√≥n de duplicaci√≥n en programaci√≥n, esto nos va a inculcar que no tengamos l√≠neas de c√≥digo duplicadas.

Toda pieza de informaci√≥n nunca deber√≠a ser duplicada debido a que incrementa la dificultad en los cambios y evoluci√≥n

La herencia nos permite crear nuevas clases a partir de otras, se basa en modelos y conceptos de la vida real. Tambi√©n tenemos una jerarqu√≠a de padre e hijo.



¬øQu√© es la herencia?
.
DRY: Don‚Äôt Repeat Yourself, consiste en promover la reducci√≥n de duplicaci√≥n en programaci√≥n. Ninguna pieza debe de ser duplicada debido a que aumenta la dificulta en los cambios y evoluci√≥n.
.
Herencia, nos permite crear nuevas clases a partir de otras, teniendo una simulaci√≥n de la vida real.
.
‚Ä¢ Clase Padre, la encontraras tambi√©n con el nombre de Sup√©rclase, y la palabra de referencia que se ocupa dentro del c√≥digo es: super.
‚Ä¢ Clase Hijo, la encontraras tambi√©n con el nombre de Subclase.
.
Recuerda: Cuando detectas caracter√≠sticas y comportamientos iguales, entonces significa que debes realizar una abstracci√≥n, herencia.



##################################################################################################################
#üìíüìíüìí ü§© Congiguraci√≥n JAVA Visual Studio Code ü§© üìíüìíüìí
###################################################################################################################

### Paso 1 üìí: 
Debemos instalar los siguientes plugins 
Java Extension Pack -> Instalara varios aditamentos 

### Paso 2 üìí:
Debemos descargar Java [OpenJDK11U-jdk_x64_windows_hotspot_11.0.11_9] ->  http://www.cs.tohoku-gakuin.ac.jp/pub/Tools/OpenJDK/JDK11-HotSpot/ 


### Paso 3 üìí: Configuramos la varibale de entorno  JAVA_HOME -> C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot 
[Como Generar Variable Entorno Windows 10](https://www.youtube.com/watch?v=qF4k830JxXo) 

### Paso 4 üìí: Debemos reiniciar el equipo  üí°üñ•Ô∏è. üí°üíª 

### Paso 5 üìí: Congigurar el Visual Code Studio 
   - Debemos buscar en Visual Code, en la secci√≥n plugins instalados -> colocamos este nombre  [Java Extension Pack]
   - En Visual code en un apesta√±a nos muestra el Welcome Java como una interfaz, debemos buscar un tittulo llamado  -> CONFIGURATION -> Configure Java Runtime  Click 
   - Te abre una interfaz donde debemos escoger lo siguiente Default JDK-> C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot 
   - En la misma interfaz InstallOpenJDK -> Radio buttom -> OpenJDK 11(LTS)
   
### Paso 6 üìí: Si creamos nuestro primer  hola mundo. 

Main.java -> 

````
<code>
package Java;
class Main {

    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }

}
````

Ya deberiamos ver el Run|Debug o con F5 para üí°üñ•Ô∏è y para  üí°üíª Tecla Fn + F5 deberia mostrar en consola del Visual Studio Code  el  ""hola mundo"" Y  Listo ü§© &starf&starf; ü§©

### Paso 7 üìí: Armarte de Mucha paciencia üí°üí°‚åõ‚åõ. 


##################################################################################################################
#üìíüìíüìí ü§© Objetos, m√©todo constructor y su sintaxis en c√≥digo ü§© üìíüìíüìí
###################################################################################################################

Un objeto es una instancia de la clase. Es decir, el objeto es el resultado de lo que modelamos 
o los par√°metros que dejamos declarados en la clase.

##################################################################################################################
#üìíüìíüìí ü§© Declarando un M√©todo Constructor en Java y JavaScript ü§© üìíüìíüìí
###################################################################################################################

Java
Person juan = new Person();
Python
persona = Person()
JavaScript
const person = new Person();
PHP
$person = new Person();
Ruby
persona = Person.new()

###################################################################################################################
#üìíüìíüìí ü§© Aplicando herencia en lenguaje Java y PHP ü§© üìíüìíüìí
###################################################################################################################

Java
class Student extends Person
Python
class Student(Person):
JavaScript
Con ES6 podemos hacerlo como en Java

class Student extends Person {
        constructor(nombre, apellido, altura, numeroDeEstudiante) {
        // con el m√©todo super() llamamos a las variables de Padre
        super(nombre, apellido, altura)
        this.numeroDeEstudiante = numeroDeEstudiante
    }
}
PHP
class Student extends Person
Ruby
class son < SuperClass
end


###################################################################################################################
#üìíüìíüìí ü§© Encapsulamiento ü§© üìíüìíüìí
###################################################################################################################

Es hacer que los datos sean inviolables, 
inalterable o hacer que se esconda, 
cuando se le asigne un Modificador de Acceso.

- Modificadores de Acceso:

- Public: Es el mas permisivos de todos, Accede a todo.
- Protected: Podr√° ser accedido por la clase, paquetes y subclases.
- Default: Permite el acceso a nivel de clses de internas y paquetes (No podremos ver las herencias si ha detener (Osea subclases))
- Private: Solo podr√° ser modificado dentro de la clase.



Cuando no se define un modificador de acceso, Java internamente asigna el modificador default.

A√±adir un modificador de acceso en Java:

private Integer passenger;
	Getters y Setters: son m√©todos que permiten acceder y modificar un dato que esta protegido por un modificador de acceso.

Creando un gettter:

public Integer getPassenger() {   // Integer ‚Üí Tipo de dato que va a retornar el m√©todo
    return passenger;
}

Creando un setter:

El getter permite acceder al dato protegido, mientras que el setter permite modificar dicho dato. Al ser ambos m√©todos de tipo public estar√°n disponibles desde cualquier lugar. A la hora de llamar estos m√©todos, no cambio nada, el proceso es el mismo que al llamar a cualquier otro m√©todo.

public void setPassenger(Integer passenger) { // void ‚Üí Indica que el m√©todo no va a retornar nada.
    this.passenger = passenger;
}


Usar getters y setter es particularmente √∫til no s√≥lo para proteger datos, sino tambi√©n para validarlos. 


###################################################################################################################
#üìíüìíüìí ü§© Generando polimorfismo en Java ü§© üìíüìíüìí
###################################################################################################################

Muchas formas. Poli = muchas, morfismo = formas. NO es Poliformismo

Es construir m√©todos con el mismo nombre pero con comportamiento diferente

Polimorfismo Es una caracter√≠stica que nos brinda la herencia en la cual 
nos ayuda a invocar m√©todos de un objeto sin necesidad de indicar directamente 
qu√© tipo de clase es (definici√≥n m√≠a, creo que me falta desarrollarla, me pueden ayudar).

En cuanto a las definiciones que se mencionan en este video, creo que son poco acertadas, 
la primera que dice es la de ‚Äú‚Ä¶construir m√©todos con el mismo nombre‚Ä¶‚Äù, pero eso es sobrecarga, y 
la otra es la de ‚Äú‚Ä¶cambiar el comportamiento de m√©todos‚Ä¶‚Äù pero eso es sobre escritura. 


Poliformismo: Muchas Formas
Construir m√©todos con el mismo nombre pero con comportamiento distinto
Ventaja: las clases pueden compartir atributos entre ellas

















