Â¿Por quÃ© aprender ProgramaciÃ³n Orientada a Objetos?

La programaciÃ³n orientada a objetos tiene cuatro caracterÃ­sticas principales:
Encapsulamiento. Quiere decir que oculta datos mediante cÃ³digo.

- AbstracciÃ³n. Es como se pueden representar los objetos en modo de cÃ³digo.
- Herencia. Es donde una clase nueva se crea a partir de una clase existente.
- Polimorfismo. Se refiere a la propiedad por la que es posible enviar mensajes sintÃ¡cticamente iguales a objetos de tipos distintos.

En este curso, los pasos a seguir serÃ¡.
Analisis
Plasmar
Programar
La mayorÃ­a solo aprende a hacer esto en un lenguajes de programaciÃ³n,aquÃ­ se tiene una variabilidad. â¤ï¸



Â¿QuÃ© resuelve la ProgramaciÃ³n OrientaciÃ³n a Objetos?



- Principalmente esos problemas y huecos que nos deja la programaciÃ³n estructurada tales como:
1.CÃ³digo muy largo:
2.Si algo falla todo se rompe
3.CÃ³digo Spaguetti: Muchas sentencias de control anidadas y pÃ©rdida de control sobre el cÃ³digo.

- Simplifica la programaciÃ³n, la hace mÃ¡s prÃ¡ctica, divertida y amigable.

Â¿QuÃ© nos ayuda a resolver la POO?
Huecos que la programaciÃ³n estructurada no resuelve, por lo que la estructuraciÃ³n por objetos surgiÃ³ como una soluciÃ³n.

Ayuda a leer, depurar y mantener cÃ³digo que puede ser muy largo.
Evita que todo se rompa si algo falla.
Facilita el mantenimiento del cÃ³digo.
Evita generar un cÃ³digo espaguetti. AquÃ©l que tiene demasiadas sentencias de control anidadas.

######################################################################################################################
# Paradigma Orientado a Objetos

La ProgramaciÃ³n Orientada a Objetos viene de una filosofÃ­a o forma de pensar que es la OrientaciÃ³n a Objetos y esto surge a partir de los problemas que necesitamos plasmar en cÃ³digo.

Es analizar un problema en forma de objetos para despuÃ©s llevarlo a cÃ³digo, eso es la OrientaciÃ³n a Objetos.

Un paradigma es una teorÃ­a que suministra la base y modelo para resolver problemas. La paradigma de ProgramaciÃ³n Orientada a Objetos se compone de 4 elementos:

Clases
Propiedades
MÃ©todos
Objetos
Y 4 Pilares:

Encapsulamiento
AbstracciÃ³n
Herencia
Polimorfismo

######################################################################################################################
# Lenguajes Orientados a Objetos

Algunos de los lenguajes de programaciÃ³n Orientados a Objetos son:

Java:
â€“ Orientado a Objetos naturalmente
â€“ Es muy Ãºtilizado en Android
â€“ Y es usado del lado del servidor o Server Side
PHP
â€“ Lenguaje interpretado
â€“ Pensado para la Web
Python
â€“ DiseÃ±ado para ser fÃ¡cil de usar
â€“ MÃºltiples usos: Web, Server Side, AnÃ¡lisis de Datos, Machine Learning, etc
Javascript
â€“ Lenguaje interpretado
â€“ Orientado a Objetos pero basado en prototipos
â€“ Pensado para la Web
C#
Ruby
Kotlin

######################################################################################################################
#Lenguajes basados en clases vs. basados en prototipos


Los lenguajes orientados a objetos basados en clases, como Java y C++, 
se basan en el concepto de dos entidades distintas: clases e instancias.


Una clase define todas las propiedades (considerando como propiedades los 
mÃ©todos y campos de Java, o los miembros de C++) que caracterizan un determinado 
conjunto de objetos. Una clase es una entidad abstracta, mÃ¡s que cualquier miembro 
en particular del conjunto de objetos que describe. Por ejemplo, la clase Empleado 
puede representar al conjunto de todos los empleados.

Una instancia, por otro lado, es la instanciaciÃ³n de una clase; es decir, uno 
de sus miembros. Por ejemplo, Victoria podrÃ­a ser una instancia de la clase Empleado, 
representando a un individuo en particular como un empleado. Una instancia tiene exactamente 
las mismas propiedades de su clase padre (ni mÃ¡s, ni menos).

Imgur
Un lenguaje basado en prototipos, como JavaScript, no hace esta distinciÃ³n: 
simplemente tiene objetos. Un lenguaje basado en prototipos toma el concepto de objeto 
prototÃ­pico, un objeto que se utiliza como una plantilla a partir de la cual se obtiene 
el conjunto inicial de propiedades de un nuevo objeto. Cualquier objeto puede especificar sus 
propias propiedades, ya sea cuando es creado o en tiempo de ejecuciÃ³n. Adicionalmente, cualquier
 objeto puede ser utilizado como el prototipo de otro objeto, permitiendo al segundo objeto compartir 
 las propiedades del primero.
 
###################################################################################################################### 
# Diagramas de Modelado

OMT: Object Modeling Techniques. Es una metodologÃ­a para el anÃ¡lisis orientado a objetos.
Creado en OMT 1991. Se encuentra en desuso.

UML: Unified Modeling Language o Lenguaje de Modelado Unificado. TomÃ³ las bases y tÃ©cnicas 
de OMT unificÃ¡ndolas. Tenemos mÃ¡s opciones de diagramas como lo son Clases, Casos de Uso, Objetos, Actividades, IteraciÃ³n, Estados, ImplementaciÃ³n.
Modelar: 
+Clases
+Casos de Uso
+Objetos
+IteraciÃ³n
+Estados
+ImplementaciÃ³n 

Creado en 1997.


Esto significa que tendremos una manera grÃ¡fica de representar una situaciÃ³n, justo como hemos venido viendo. A continuaciÃ³n te voy a presentar los elementos que puedes utilizar para hacer estas representaciones.

Las clases se representan asÃ­:

clase.png
En la parte superior se colocan los atributos o propiedades, y debajo las opera ciones de la clase. NotarÃ¡s que el primer caracter con el que empiezan es un sÃ­mbolo. Este denotarÃ¡ la visibilidad del atributo o mÃ©todo, esto es un tÃ©rmino que tiene que ver con Encapsulamiento y veremos mÃ¡s adelante a detalle.

Estos son los niveles de visibilidad que puedes tener:

- private
+ public
# protected
~ default

Una forma de representar las relaciones que tendrÃ¡ un elemento con otro es a travÃ©s de las flechas en UML, y aquÃ­ tenemos varios tipos, estos son los mÃ¡s comunes:

AsociaciÃ³n
associacion.png
Como su nombre lo dice, notarÃ¡s que cada vez que estÃ© referenciada este tipo de flecha significarÃ¡ que ese elemento contiene al otro en su definiciÃ³n. La flecha apuntarÃ¡ hacia la dependencia.

uml-relacion-asociacion.jpg
Con esto vemos que la ClaseA estÃ¡ asociada y depende de la ClaseB.

Herencia
herencia.png
Siempre que veamos este tipo de flecha se estarÃ¡ expresando la herencia.
La direcciÃ³n de la flecha irÃ¡ desde el hijo hasta el padre.

herencia-clases.png
Con esto vemos que la ClaseB hereda de la ClaseA

AgregaciÃ³n
agregacion.png
Este se parece a la asociaciÃ³n en que un elemento dependerÃ¡ del otro, pero en este caso serÃ¡: Un elemento dependerÃ¡ de muchos otros. AquÃ­ tomamos como referencia la multiplicidad del elemento. Lo que comÃºnmente conocerÃ­as en Bases de Datos como Relaciones uno a muchos.

uml-relacion-agregacion.jpg
Con esto decimos que la ClaseA contiene varios elementos de la ClaseB. Estos Ãºltimos son comÃºnmente representados con listas o colecciones de datos.

ComposiciÃ³n
composicion.png
Este es similar al anterior solo que su relaciÃ³n es totalmente compenetrada de tal modo que conceptualmente una de estas clases no podrÃ­a vivir si no existiera la otra.

uml-relacion-composicion.jpg
Con esto terminamos nuestro primer mÃ³dulo. Vamos al siguiente para entender cÃ³mo podemos hacer un anÃ¡lisis y utilizar estos elementos para construir nuestro diagrama de clases de Uber.

#################################################################################################################
#Objetos


ğŸ’¡ Es importante tener en cuenta que el atributo no sea el resultado. Ej: el atributo de ser nombre, 
no el resultado del atributo.

AdemÃ¡s, los objetos tambiÃ©n puede tener comportamientos. Estos serÃ¡n todas las operaciones del 
objeto, suelen ser â€˜verbosâ€™ o â€˜sustantivo y verboâ€™.

login() â†’ Verbo
logout() â†’ Verbo
makeReport() â†’ Sustantivo y verbo
ğŸ“’ Es importante tener en cuenta el contexto en que estÃ¡n mis objetos.

Los Objetos son aquellos que tienen propiedades y comportamientos, tambiÃ©n serÃ¡n sustantivos.

Pueden ser FÃ­sicos o Conceptuales
Las Propiedades tambiÃ©n pueden llamarse atributos y estos tambiÃ©n serÃ¡n sustantivos. Algunos atributos o propiedades son nombre, tamaÃ±o, forma, estado, etc. Son todas las caracterÃ­sticas del objeto.

Los Comportamientos serÃ¡n todas las operaciones que el objeto puede hacer, suelen ser verbos o sustantivos y verbo. Algunos ejemplos pueden ser que el usuario pueda hacer login y logout.

#################################################################################################################
#Clase


Una Clase es el modelo por el cual nuestros objetos se van a construir y nos van a permitir generar mÃ¡s objetos.

Analizamos Objetos para crear Clases. Las Clases son los modelos sobres los cuales construiremos nuestros objetos.

AbstracciÃ³n es cuando separamos los datos de un objeto para generar un molde.

#################################################################################################################
#Modularidad
.
La modularidad va de la mano con el DiseÃ±o Modular, este consiste en dividir 
nuestro sistema en partes pequeÃ±as que funcionen de manera independiente.

Ventajas
-Reutilizar cÃ³digo
-Evitar colapsos
-Legibilidad (Todos los elementos viven por sÃ­ solos)
-ResoluciÃ³n rÃ¡pida de problemas

Debemos empezar a programar en pequeÃ±os trozos, cambiar nuestra forma de pensar y evitar la programaciÃ³n estructurada.

Tengamos presentes los principios de la

##################################################################################################################
Â¿QuÃ© es la herencia?

##################################################################################################################
#Cuando detecto caracterÃ­sticas y comportamientos iguales, entonces significa que debo realizar una abstracciÃ³n.
###################################################################################################################

Donâ€™t repeat yourself es una filosofÃ­a que promueve la reducciÃ³n de duplicaciÃ³n en programaciÃ³n, esto nos va a inculcar que no tengamos lÃ­neas de cÃ³digo duplicadas.

Toda pieza de informaciÃ³n nunca deberÃ­a ser duplicada debido a que incrementa la dificultad en los cambios y evoluciÃ³n

La herencia nos permite crear nuevas clases a partir de otras, se basa en modelos y conceptos de la vida real. TambiÃ©n tenemos una jerarquÃ­a de padre e hijo.



Â¿QuÃ© es la herencia?
.
DRY: Donâ€™t Repeat Yourself, consiste en promover la reducciÃ³n de duplicaciÃ³n en programaciÃ³n. Ninguna pieza debe de ser duplicada debido a que aumenta la dificulta en los cambios y evoluciÃ³n.
.
Herencia, nos permite crear nuevas clases a partir de otras, teniendo una simulaciÃ³n de la vida real.
.
â€¢ Clase Padre, la encontraras tambiÃ©n con el nombre de SupÃ©rclase, y la palabra de referencia que se ocupa dentro del cÃ³digo es: super.
â€¢ Clase Hijo, la encontraras tambiÃ©n con el nombre de Subclase.
.
Recuerda: Cuando detectas caracterÃ­sticas y comportamientos iguales, entonces significa que debes realizar una abstracciÃ³n, herencia.



##################################################################################################################
#ğŸ“’ğŸ“’ğŸ“’ ğŸ¤© CongiguraciÃ³n JAVA Visual Studio Code ğŸ¤© ğŸ“’ğŸ“’ğŸ“’
###################################################################################################################

### Paso 1 ğŸ“’: 
Debemos instalar los siguientes plugins 
Java Extension Pack -> Instalara varios aditamentos 

### Paso 2 ğŸ“’:
Debemos descargar Java [OpenJDK11U-jdk_x64_windows_hotspot_11.0.11_9] ->  http://www.cs.tohoku-gakuin.ac.jp/pub/Tools/OpenJDK/JDK11-HotSpot/ 


### Paso 3 ğŸ“’: Configuramos la varibale de entorno  JAVA_HOME -> C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot 
[Como Generar Variable Entorno Windows 10](https://www.youtube.com/watch?v=qF4k830JxXo) 

### Paso 4 ğŸ“’: Debemos reiniciar el equipo  ğŸ’¡ğŸ–¥ï¸. ğŸ’¡ğŸ’» 

### Paso 5 ğŸ“’: Congigurar el Visual Code Studio 
   - Debemos buscar en Visual Code, en la secciÃ³n plugins instalados -> colocamos este nombre  [Java Extension Pack]
   - En Visual code en un apestaÃ±a nos muestra el Welcome Java como una interfaz, debemos buscar un tittulo llamado  -> CONFIGURATION -> Configure Java Runtime  Click 
   - Te abre una interfaz donde debemos escoger lo siguiente Default JDK-> C:\Program Files\AdoptOpenJDK\jdk-11.0.11.9-hotspot 
   - En la misma interfaz InstallOpenJDK -> Radio buttom -> OpenJDK 11(LTS)
   
### Paso 6 ğŸ“’: Si creamos nuestro primer  hola mundo. 

Main.java -> 

````
<code>
package Java;
class Main {

    public static void main(String[] args) {
        System.out.println("Hola Mundo");
    }

}
````

Ya deberiamos ver el Run|Debug o con F5 para ğŸ’¡ğŸ–¥ï¸ y para  ğŸ’¡ğŸ’» Tecla Fn + F5 deberia mostrar en consola del Visual Studio Code  el  ""hola mundo"" Y  Listo ğŸ¤© &starf&starf; ğŸ¤©

### Paso 7 ğŸ“’: Armarte de Mucha paciencia ğŸ’¡ğŸ’¡âŒ›âŒ›. 


##################################################################################################################
#ğŸ“’ğŸ“’ğŸ“’ ğŸ¤© Objetos, mÃ©todo constructor y su sintaxis en cÃ³digo ğŸ¤© ğŸ“’ğŸ“’ğŸ“’
###################################################################################################################

Un objeto es una instancia de la clase. Es decir, el objeto es el resultado de lo que modelamos 
o los parÃ¡metros que dejamos declarados en la clase.

##################################################################################################################
#ğŸ“’ğŸ“’ğŸ“’ ğŸ¤© Declarando un MÃ©todo Constructor en Java y JavaScript ğŸ¤© ğŸ“’ğŸ“’ğŸ“’
###################################################################################################################

Java
Person juan = new Person();
Python
persona = Person()
JavaScript
const person = new Person();
PHP
$person = new Person();
Ruby
persona = Person.new()

###################################################################################################################
#ğŸ“’ğŸ“’ğŸ“’ ğŸ¤© Aplicando herencia en lenguaje Java y PHP ğŸ¤© ğŸ“’ğŸ“’ğŸ“’
###################################################################################################################

Java
class Student extends Person
Python
class Student(Person):
JavaScript
Con ES6 podemos hacerlo como en Java

class Student extends Person {
        constructor(nombre, apellido, altura, numeroDeEstudiante) {
        // con el mÃ©todo super() llamamos a las variables de Padre
        super(nombre, apellido, altura)
        this.numeroDeEstudiante = numeroDeEstudiante
    }
}
PHP
class Student extends Person
Ruby
class son < SuperClass
end


###################################################################################################################
#ğŸ“’ğŸ“’ğŸ“’ ğŸ¤© Encapsulamiento ğŸ¤© ğŸ“’ğŸ“’ğŸ“’
###################################################################################################################

Es hacer que los datos sean inviolables, 
inalterable o hacer que se esconda, 
cuando se le asigne un Modificador de Acceso.

- Modificadores de Acceso:

- Public: Es el mas permisivos de todos, Accede a todo.
- Protected: PodrÃ¡ ser accedido por la clase, paquetes y subclases.
- Default: Permite el acceso a nivel de clses de internas y paquetes (No podremos ver las herencias si ha detener (Osea subclases))
- Private: Solo podrÃ¡ ser modificado dentro de la clase.



Cuando no se define un modificador de acceso, Java internamente asigna el modificador default.

AÃ±adir un modificador de acceso en Java:

private Integer passenger;
	Getters y Setters: son mÃ©todos que permiten acceder y modificar un dato que esta protegido por un modificador de acceso.

Creando un gettter:

public Integer getPassenger() {   // Integer â†’ Tipo de dato que va a retornar el mÃ©todo
    return passenger;
}

Creando un setter:

El getter permite acceder al dato protegido, mientras que el setter permite modificar dicho dato. Al ser ambos mÃ©todos de tipo public estarÃ¡n disponibles desde cualquier lugar. A la hora de llamar estos mÃ©todos, no cambio nada, el proceso es el mismo que al llamar a cualquier otro mÃ©todo.

public void setPassenger(Integer passenger) { // void â†’ Indica que el mÃ©todo no va a retornar nada.
    this.passenger = passenger;
}


Usar getters y setter es particularmente Ãºtil no sÃ³lo para proteger datos, sino tambiÃ©n para validarlos. 


###################################################################################################################
#ğŸ“’ğŸ“’ğŸ“’ ğŸ¤© Generando polimorfismo en Java ğŸ¤© ğŸ“’ğŸ“’ğŸ“’
###################################################################################################################

Muchas formas. Poli = muchas, morfismo = formas. NO es Poliformismo

Es construir mÃ©todos con el mismo nombre pero con comportamiento diferente

Polimorfismo Es una caracterÃ­stica que nos brinda la herencia en la cual 
nos ayuda a invocar mÃ©todos de un objeto sin necesidad de indicar directamente 
quÃ© tipo de clase es (definiciÃ³n mÃ­a, creo que me falta desarrollarla, me pueden ayudar).

En cuanto a las definiciones que se mencionan en este video, creo que son poco acertadas, 
la primera que dice es la de â€œâ€¦construir mÃ©todos con el mismo nombreâ€¦â€, pero eso es sobrecarga, y 
la otra es la de â€œâ€¦cambiar el comportamiento de mÃ©todosâ€¦â€ pero eso es sobre escritura. 


Poliformismo: Muchas Formas
Construir mÃ©todos con el mismo nombre pero con comportamiento distinto
Ventaja: las clases pueden compartir atributos entre ellas

















